{
  "name": "iz",
  "version": "0.7.1",
  "description": "Validation for node and the web.",
  "main": "app.js",
  "url": "https://github.com/parris/iz/issues",
  "homepage": "https://github.com/parris/iz",
  "keywords": [
    "validation",
    "regex",
    "checker"
  ],
  "repository": {
    "type": "git",
    "url": "git@github.com:parris/iz.git"
  },
  "dependencies": {},
  "devDependencies": {
    "mocha": "~1.1.0",
    "should": "~0.6.3",
    "grunt": "~0.4.1",
    "grunt-simple-mocha": "git://github.com/yaymukund/grunt-simple-mocha.git#a4946466e9ce5504ecbda4d8419ff28ab74585ff",
    "grunt-cli": "~0.1.9",
    "grunt-contrib-requirejs": "~0.4.1",
    "bower": "~1.2.2"
  },
  "scripts": {
    "test": "./node_modules/.bin/grunt test",
    "build": "./node_modules/.bin/grunt"
  },
  "author": {
    "name": "Parris Khachi"
  },
  "license": "Apache-2.0",
  "readme": "[![Build Status](https://secure.travis-ci.org/parris/iz.png)](http://travis-ci.org/parris/iz)\n\nWhat is it?\n====\nA validation library written for client/server side needs in javascript. Oh and awesome syntax is important to us too.\n\nSetup\n====\n\nServer side (Node/CommonJS)\n----\n\n    npm install iz --save\n\nThen you can include iz, are and validators if needed\n\n    var iz = require('iz'),\n        are = iz.are,\n        validators = iz.validators;\n\nClient Side\n----\nThis depends on situation. If you are using CommonJS modules use the server side syntax.\n\nIf you are using AMD modules, you can include files from the amd folder like so:\n\n    require(function(require) {\n        var iz = require('node_modules/iz/amd/iz'),\n            are = require('node_modules/iz/amd/are'),\n            validators = require('node_modules/iz/amd/validators');\n    });\n\nIf you are **not** using a module system you may want to take a look at OneJS/Browserify, and how we did client side builds in v0.2.0 (just view the tag on github).\n\nAPI\n====\nChaining:\n----\n\n    iz(10).between(2, 15).int().multiple(5); //why yes, yes it is\n    iz(10).not().between(1, 5); // the fancy not operator will cause the opposite result to happen next. This is also true!\n\niz(), and all validation commands return an Iz object. An iz object always contains an `errors`{array} and `valid`{bool}. `errors` will be filled with a default error messsage for each incorrect field. To provide custom error messages you can do the following:\n\n    var errors = {\n        between: 'Is not between, please fix',\n        not_between: 'Value must be between!',\n        int: 'Not an int!!!',\n        multiple: 'This is terrible and you should fix it'\n    }\n    iz('Bob', errors).between(2, 15).int().multiple(5);\n\nSimple Checks\n----\nYou don't need to use the chained notation. The following will return true or false:\n\n    iz.between(3, 2, 5); //is 3, between 2 and 5?\n\nJSON\n----\nIt is often useful to get a list of validations from your server for a given model. Nested objects work to!\n\n    var rules = {\n        'cost': [\n            {\n                'rule': 'between',\n                'args': [17, 1000],\n                'error': 'The cost must be between 17, 1000'\n            },\n            {\n                'rule': 'required',\n                'error': 'You must specify a cost'\n            },\n        ],\n        'producer.id': [\n            {\n                'rule': 'int',\n                'error': 'Producer ID must be an int'\n            }\n        ],\n        'producer.name.first': [\n            {\n                'rule': 'alphaNumeric',\n                'error': 'Must be names and numbers'\n            }\n        ]\n    };\n\n    are(rules).validFor({\n        cost: 20,\n        producer: {\n            id: 1,\n            name: {\n                first: 'bob'\n            }\n        }\n    });\n\nAre/Multiple rules\n----\n`are` doesn't just force you to use json validations. You could also check if any number of chained or json rules are valid.\n\n    var wine = new Bottle({age: 30, cost: 1000.01}),\n        costErrors = {\n            number: 'Cost must be given as a number'\n        },\n        ageErrors = {\n            int: 'Must be an whole number',\n            between: 'This wine is too young, it\\'s no good'\n        },\n        rules = {\n            cost: iz(wine.cost, costErrors).decimal(),\n            age: iz(wine.age, ageErrors)\n                .int().between(17, 10000)\n        },\n        areRules = are(rules);\n\n    areRules.valid(); // true\n\n    rules.cost.setValue(2000.00);\n    areRules.valid(); // true, setValue revalidates, as does are.valid\n\n    rules.cost('hi'); // we didn't use setValue on the Iz cost object\n    rules.cost.valid; // and valid is still true\n\n    are(rules).valid() // but `valid()` will revalidate, false\n    rules.cost.valid // and `valid` is now in the correct state again\n\n    // or you can use this and just give null values in the rules object\n    areRules.validFor(wine)\n\nIt is often useful to get back error messages from an Are object. Regardless of\nhow you create your Are object (JSON or Iz objects) the result is a set of Iz\nobjects stored within `.fields`. Iz objects contain an attribute called `errors`.\nThe `.getInvalidFields` helper will retrieve all iz objects with errors.\n\n    var rules = Are(...);\n\n    if (!rules.validFor(someAttributeObject)) {\n        return rules.getInvalidFields();\n    }\n\nError Messages:\n----\nIn the event you want to return more detailed error messages. You can use a\nsimple syntax to format your error message with a validators arguments.\n\n    var error_messages = {between: '{{0}} is not between {{1}} and {{2}}'};\n    var izObj = iz(5, error_messages).between(100, 200);\n    console.log(izObj.errors);\n\nwill log `['5 is not between 100 and 200']`. This works with\n`are.getInvalidFields()` too.\n\nRequired Fields:\n----\nIn most cases, you'll only want to validate values when they exist. By default iz functions in this way. If you want to force the presence of a value you can use the `required` method.\n\n    iz(value).required() //a value is required\n    iz(value).required().email() //value is required and is a valid email\n    iz(value).date() //value is not required but must be a date if provided\n\nValidators:\n----\nAll validators (apart from iz.required) return true if no value is provided (e.g. null, undefined or '').\n\nValidations (true case in comments):\n\n    iz.alphaNumeric(*);               // Is number or string(contains only numbers or strings)\n    iz.between(number, start, end);   // Number is start or greater but less than or equal to end, all params numeric\n    iz.blank(*);                      // Empty string\n    iz.boolean(*);                    // true, false, 0, 1\n    iz.cc(*);                         // Luhn checksum approved value\n    iz.date(*);                       // Is a date obj or is a string that is easily converted to a date\n    iz.decimal(*);                    // int or float\n    iz.email(*);                      // Seems like a valid email address\n    iz.empty(*);                      // If an object, array or function contains no properties true. All primitives return true.\n    iz.equal(*, *);                   // Any 2 things are strictly equal. If 2 objects their internal properties will be checked. If the first parameter has an equals method that will be run instead\n    iz.extension(ob1, ob2);           // If obj2's methods are all found in obj1\n    iz.fileExtension(value, arr);     // Checks if the extension of value is in arr. An obj can be provide, but must have indexOf defined.\n    iz.fileExtensionAudio(value);     // Check against mp3, ogg, wav, aac\n    iz.fileExtensionImage(value);     // Check against png, jpg, jpeg, gif, bmp, svg, gif\n    iz.inArray(value, arr);           // If * is in the array\n    iz.anArray(arr);                  // If arr is an array\n    iz.int(*, bool (optional));       // Is an int. If the 2nd variable is true (false by default) a decimal is allowed\n    iz.ip(str);                       // str resembles an IPV4 or IPV6 address\n    iz.minLength(val, min);           // val (str or arr) is greater than min\n    iz.maxLength(val, max);           // val (str or arr) is shorter than max\n    iz.multiple(num, mult);           // Number is multiple of another number\n    iz.number(*);                     // Is either an int or decimal\n    iz.ofType(obj, typeName);         // If it is a named object, and the name matches the string\n    iz.phone(str, canHaveExtension?); // Is an american phone number. Any punctuations are allowed.\n    iz.postal(*);                     // Is a postal code or zip code\n    iz.required(*);                   // Is not null, undefined or an empty string\n    iz.ssn(*);                        // Is a social security number\n    iz.string(*);                     // Is the argument of type string\n\nAlmost all possible use cases that will definitely work (and definitely not work) are in the spec folder.\n\nCustom Validators:\n----\nAdding custom validators is done though either the validation or iz object.  If the validator already exists, then addValidator will throw an exception.  You can force an override by adding a 3rd parameter of true.\n\n\n    var dummyValidator = function(value){\n        if(typeof value !=='string'){\n            return false;\n        }\n        return value.indexOf('test') === 0;\n    };\n    iz.addValidator('startsWithTest', dummyValidator);\n    iz.startsWithTest('test string');\n\n    //for override of existing validator, only do this if you are sure.\n    iz.addValidator('string', dummyValidator, true);\n\n\n\n\nOmmissions\n====\n- Uniqueness: This is non-trivial since it requires db/server side/client side knowledge.\n- File: Not sure what the scope should be yet. Mime types? Existence on the web?\n- Email (more in depth): Right now we check for the @ symbol. There are extremely complicated regex out there. I haven't really found the need. If you have an idea send a pull request!\n- Money: The scope is really large. I am thinking about having localized settings.\n- URL: No real non-crazy regex exists. Checking for http:// at the front is lame, why force your user to type that in?\n\nDid I miss a validation? Send me a message or a pull request.\n\nRoadmap\n====\n- Simplify creation of Iz objects. Too much construction happens right now.\n- Allow developers to pass custom rjs options for a custom iz build\n\nChange Log\n====\n\n0.7.0\n----\n- Added `iz.addValidator` method to add custom validations more effectively\n\n0.6.0\n----\n- Added `is.anArray` validation\n\n0.5.2\n----\n- Removed a strange hidden character that was introduced\n\n0.5.0\n----\n- Added interpolation to error messages\n- Added bower\n- Changed license and copyright info\n- Fixed readme typos\n\n0.4.1\n----\n- Changed AMD compile process\n- Rebuilt modules as AMD\n- Split out tasks into their own files\n- Added roadmap\n- Fixed up more docs\n\n0.4.0\n----\n- Renamed private `_fields` variable in Are to `fields`\n- Added `getInvalidFields` to Are\n- Added `iz.string` validation\n- Fixed docs\n\n0.3.0\n----\n- Added JSON based validations\n- Replaced previous build system with requirejs.\n- Doc simplification\n- Code style reformatting\n\n0.2.0\n----\n- Added iz.required()\n- Falsy values now pass through as valid without `.required`\n\n0.1.0\n----\n- Fixed loading of iz, are and validator modules\n- Added missing 'blank' validator\n- Added build/test system via grunt\n- Removed versions in bin\n- Added version/generation number in banner\n- Changed file structure\n\n0.0.4\n----\n- Revalidation was added to iz\n- Add are() for group validation\n- Clean-up of syntax/optimizations\n\n0.0.3\n----\n- Added equal method\n- Added empty method\n- Added not() operation\n\n0.0.2\n----\n- Re-ordered parameters for fileExtension and inArray\n- Added method chaining\n- Added error messages\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/parris/iz/issues"
  },
  "_id": "iz@0.7.1",
  "_from": "iz@~0.7.1"
}
